# Stack and Queue

물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조



스택에 저장된 자료는 선형구조임



마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(LIFO, Last in First out)



재귀호출도 일종의 스택임



## DP (Dynamic Programming)

그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘



입력 크기가 작은 부분 문제드릉ㄹ 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘



가장 대표적인 예로 피보나치 수열이 있음



```python
def fibo(n):
    f = [0, 1]
    for i in range(2, n+1):
        f.append(f[n-1]+f[i-2])
    
    return f[n]
```





## DFS 깊이 우선 탐색

시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더이상 갈 곳이 없게 되면 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법



가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용





## Backtracking

해를 찾는 도중 막히면(즉 해가 아니면) 되돌아가서 해를 찾아가는 기법임



백트래킹으로 최적화문제와 결정 문제를 해결할 수 잇음



결정문제 : 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes or no로 답하는 문제



백트래킹 vs dfs

dfs는 모든 경로를 추적함

백트래킹은 해결책으로서의 가망이 없으면 포기하므로 불필요한 경로를 조기 차단



백트래킹 기법

- 어떤 노드의 유망성을 점검 후 유망하지 않다면 부모 노드로 돌아가 그 다음 자식 노드로 간다
- 어떤 노드를 방문했을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않음.
- pruning = 가지치기





## Quick sort

주어진 배열을 두개로 분할하고, 각각을 정렬한다

분할 할 때, 기준(pivot)을 중심으로 작으면 왼편, 크면 오른편에 위치시킨다.



merge sort와 다른 점

각 부분정렬이 끝난 후, merge sort는 합병이란 후처리 작업이 필요

But quick sort는 필요로 하지 않음



~~~python
def quicksort(arr, begin, end):
    if begin < end:
        p = partition(arr, begin, end)
        quicksort(arr, begin, p-1)
        quicksort(arr, p+1, end)
        

def partition(arr, begin, end):
    pivot = (begin + end) // 2	# 임의로 설정
    l = begin
    r = end
    
    while l < r:
        while l < r and arr[l] < arr[pivot]:
            l += 1
        while l < r and arr[r] >= arr[pivot]:
            r -= 1
            
        if l < r:
            if l == pivot:
                pivot = r
            a[l], a[r] = a[r], a[l]
    a[pivot], a[r] = a[r], a[pivot]
    return r
~~~



시간복잡도

O(nlogn) / 최악 : O(n^2)





## Queue

선입 선출 구조 FIFO (First in First out)

큐에 삽입한 순서로 원소가 저장되고 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.





## 원형큐

선형 큐 이용시, 원소의 입출력을 반복하다 보면 앞에 자리가 비었음에도 불구하고 이 것을 인식 못하는 경우가 있는데, 이 단점을 극복하고자 만들어짐



원형큐 구조

front = rear = 0

front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후 그 당므에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함

이 것을 원활히 하기 위해 % 나머지 연산자를 사용함



## 우선순위 큐 Priority Queue

우선순위를 가진 항목들을 저장하는 큐

FIFO순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다



응용 분야

시뮬레이션 시스템

네트워크 트래픽 제어

운영체제의 테스크 스케줄링



1. 배열을 이용하는 우선순위 큐

   - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
   - 가장 앞에 최고 우선순위의 원소가 위치하게 됨

   - 배열을 사용하므로 삽입, 삭제 연산이 일어날 때 원소의 재배치가 발생함.
   - 이에 소요되는 시간이나 메모리 낭비가 큼



## BFS (Breadth First Search)

탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식



인접한 정점들에 대해 탐색한 후 차례로 다시 너비우선탐색을 진행해야 하므로 선입선출 형태의 자료구조인 큐를 이용한다



